# docin project Makefile
# Deploy projects with containerised docker-compose

SHELL         = /bin/bash
CFG          ?= .env

# container prefix
PROJECT_NAME ?= hostname_domain

# website host
APP_SITE     ?= test.dev.lan

# dcape net connect to
DCAPE_NET    ?= dcape_default

# docker-compose version
DC_VER        = 1.14.0

# used by deploy system
DOCKER_BIN   ?= docker

# -----------------------------------------------------------------------------

-include $(CFG)
export

# make игнорирует файлы с этими именами
.PHONY: all up down setup start-hook stop dcrun help

## (ре)старт контейнера
up:
up: CMD=up --force-recreate -d
up: dc

## остановка и удаление контейнера
down:
down: CMD=rm -f -s
down: dc

setup: $(CFG)

start-hook: CMD=up -d
start-hook: dc
	@echo "*** $@ ***"

stop: down
	@echo "*** $@ ***"

update:
	@echo "*** $@ ***"

all: help

# ------------------------------------------------------------------------------
# Setup targets

# Файл .config
define CONFIG_DEF
# project config file, generated by make $(CFG)

# container prefix
PROJECT_NAME=$(PROJECT_NAME)

# website host
APP_SITE=$(APP_SITE)

# dcape network connect to, must be set in .env
DCAPE_NET=dockin_default

endef
export CONFIG_DEF

$(CFG):
	@echo "*** $@ ***"
	@[ -f $@ ] || echo "$$CONFIG_DEF" > $@

# ------------------------------------------------------------------------------

# $$PWD используется для того, чтобы текущий каталог был доступен в контейнере по тому же пути
# и относительные тома новых контейнеров могли его использовать
## run docker-compose
dc: docker-compose.yml
	@$$DOCKER_BIN run --rm  -i \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -v $$PWD:$$PWD \
  -w $$PWD \
  docker/compose:$$DC_VER \
  -p $$PROJECT_NAME \
  $(CMD)

#  --env=golang_version=$$GO_VER \
#  --env=cron_version=$$CRON_VER \


help:
	@grep -A 1 "^##" Makefile | less

##
## Press 'q' for exit
##
